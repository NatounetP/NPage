<!DOCTYPE html>
<html>
<head>
    <title>F**K Your NACHBAR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* General Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #app {
            flex: 1;
            max-width: 90%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        h1, h2 {
            color: #333;
            text-align: center;
        }

        .setup, .game {
            margin-bottom: 20px;
        }

        .hidden {
            display: none;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="number"], input[type="text"] {
            width: 90%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px; /* Prevent zooming on mobile */
        }

        button {
            width: 100%;
            padding: 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #218838;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }

        .player-column {
            background-color: #f8f9fa;
        }

        .score-positive {
            color: green;
        }

        .score-negative {
            color: red;
        }

        /* Updated Footer Styles */
.footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #f8f9fa;
    padding: 10px;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding-top: 20px; /* Move buttons higher */
}

.footer-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
    max-width: 400px;
    margin: 0 auto;
}

        .footer input[type="number"] {
            width: 60px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px; /* Prevent zooming on mobile */
        }

        .footer button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .footer button:hover {
            background-color: #0056b3;
        }

        .footer-info {
            font-weight: bold;
            text-align: center;
        }

        /* Responsive Design for Phones */
        @media screen and (max-width: 600px) {
            #app {
                padding: 10px;
            }

            h1 {
                font-size: 24px;
            }

            h2 {
                font-size: 20px;
            }

            input[type="number"], input[type="text"] {
                font-size: 16px;
            }

            button {
                font-size: 16px;
            }

            table {
                font-size: 14px;
            }

            th, td {
                padding: 8px;
            }

            .footer-content {
                flex-direction: column;
                gap: 5px;
            }

            .footer input[type="number"] {
                width: 100%;
            }

            .footer button {
                width: 50%;
            }
        }
	/* Updated Number Buttons */
.number-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Two columns */
    gap: 5px;
    width: 100%;
    max-width: 200px; /* Adjust width to fit two columns */
}

.number-button {
    padding: 10px 15px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    text-align: center;
}

.number-button:disabled {
    background-color: #ccc; /* Disabled button color */
    cursor: not-allowed; /* Show not-allowed cursor */
    opacity: 0.6; /* Make it look disabled */
}

.number-button:hover:not(:disabled) {
    background-color: #0056b3;
}

        .footer {
            padding: 15px;
        }

        .footer-content {
            flex-direction: column;
            gap: 10px;
        }
/* Style pour le bouton de réduction/déroulement */
.toggle-footer-button {
    position: absolute; /* Position absolue pour le placer en haut */
    top: -30px; /* Déplacer le bouton au-dessus du footer */
    left: 50%; /* Centrer horizontalement */
    transform: translateX(-50%); /* Ajuster le centrage */
    width: 40px; /* Largeur réduite */
    height: 30px; /* Hauteur réduite */
    padding: 5px;
	justify-content: center;
    background-color: #007bff; /* Couleur de fond */
    color: white; /* Couleur du texte */
    border: none;
    border-radius: 4px 4px 0 0; /* Arrondir uniquement le haut */
    cursor: pointer;
    font-size: 14px; /* Taille de police réduite */
    text-align: center;
    box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* Ombre légère */
    z-index: 1001; /* S'assurer qu'il est au-dessus du footer */
}

.toggle-footer-button:hover {
    background-color: #0056b3; /* Changement de couleur au survol */
}

/* Classe pour masquer le contenu du footer */
.footer-content.collapsed {
    display: none;
}

/* Ajustement du footer pour éviter que le bouton ne chevauche le contenu */
.footer {
    position: relative; /* Nécessaire pour positionner le bouton en absolute */
    padding-top: 10px; /* Espace pour le bouton */
}
        .ranking {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .ranking-item {
            background-color: #f8f9fa;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .rank {
            font-weight: bold;
            min-width: 20px;
        }

        @media screen and (max-width: 600px) {
            .number-button {
                min-width: 40px;
                padding: 8px 12px;
            }

            .ranking {
                font-size: 12px;
            }

            .ranking-item {
                padding: 3px 8px;
            }
        }

    </style>
</head>
<body>
    <div id="app">
        <h1>F**k Your Nachbar</h1>
        
        <div id="setup" class="setup">
            <h2>Configuration de la partie</h2>
            <div>
                <label for="playerCount">Nombre de joueurs (2-6) :</label>
                <input type="number" id="playerCount" min="2" max="6" value="2">
            </div>
            <button onclick="setupPlayers()">Suivant</button>
        </div>

        <div id="playerNames" class="setup hidden">
            <h2>Noms des joueurs</h2>
            <div class="player-order-info">
                Important : Entrez les noms des joueurs dans l'ordre anti-horaire en partant du premier donneur
            </div>
            <div id="playerInputs"></div>
            <button onclick="startGame()">Commencer la partie</button>
        </div>

        <div id="game" class="game hidden">
            <h2><div id="roundDescription" class="round-description"></div></h2>
            <div class="round-info">
                Ronde <span id="currentRound">1</span>/<span id="totalRounds">15</span>
                
            </div>
            <div id="scoreTable"></div>
        </div>
    </div>

    <!-- Footer for input -->
    <div id="footer" class="footer">
    <button id="toggleFooterButton" class="toggle-footer-button">-</button>
    <div class="footer-content">
        <div class="ranking" id="rankingDisplay"></div>
        <div class="footer-info" id="footerMessage"></div>
        <div class="number-buttons" id="numberButtons"></div>
    </div>
</div>


    <script>
        // Configuration initiale
        const roundDescriptions = {
            15: [
                "7 cartes",
                "6 cartes",
                "5 cartes",
                "4 cartes",
                "3 cartes",
                "2 cartes",
                "1 carte",
                "1 carte sans regarder",
                "1 carte",
                "2 cartes",
                "3 cartes",
                "4 cartes",
                "5 cartes",
                "6 cartes",
                "7 cartes (Final)"
            ],
            13: [
                "6 cartes",
                "5 cartes",
                "4 cartes",
                "3 cartes",
                "2 cartes",
                "1 carte",
                "1 carte sans regarder",
                "1 carte",
                "2 cartes",
                "3 cartes",
                "4 cartes",
                "5 cartes",
                "6 cartes (Final)"
            ]
        };

        // État du jeu
        let gameState = {
            players: [],
            rounds: [],
            currentRound: 0,
            totalRounds: 15,
            currentRoundDescriptions: null,
            currentPlayerIndex: 0,
            startingPlayerIndex: 0,
            currentBets: [],
            currentScores: [],
            isCollectingBets: true
        };

        // Fonction utilitaire pour extraire le nombre de cartes
        function getCardsFromDescription(description) {
            const words = description.split(' ');
            return words[0] === "Final" ? parseInt(words[2]) : parseInt(words[0]);
        }
	// Fonction pour basculer l'état du footer
function toggleFooter() {
    const footerContent = document.querySelector('.footer-content');
    const toggleButton = document.getElementById('toggleFooterButton');

    if (footerContent.classList.contains('collapsed')) {
        // Dérouler le footer
        footerContent.classList.remove('collapsed');
        toggleButton.textContent = '-'; // Flèche vers le haut
    } else {
        // Réduire le footer
        footerContent.classList.add('collapsed');
        toggleButton.textContent = '+'; // Flèche vers le bas
    }
}

// Ajouter un écouteur d'événement au bouton
document.getElementById('toggleFooterButton').addEventListener('click', toggleFooter);

        // Initialisation de la partie
        function setupPlayers() {
            const playerCount = parseInt(document.getElementById('playerCount').value);
            if (playerCount < 2 || playerCount > 6) {
                alert('Le nombre de joueurs doit être entre 2 et 6');
                return;
            }

            gameState.totalRounds = playerCount === 6 ? 13 : 15;
            gameState.currentRoundDescriptions = roundDescriptions[gameState.totalRounds];
            document.getElementById('totalRounds').textContent = gameState.totalRounds;

            const playerInputs = document.getElementById('playerInputs');
            playerInputs.innerHTML = '';
            
            for (let i = 0; i < playerCount; i++) {
                playerInputs.innerHTML += `
                    <div>
                        <label for="player${i}">Joueur ${i + 1}:</label>
                        <input type="text" id="player${i}" required>
                    </div>
                `;
            }

            document.getElementById('setup').classList.add('hidden');
            document.getElementById('playerNames').classList.remove('hidden');
        }

        // Démarrage de la partie
        function startGame() {
            gameState.players = [];
            const inputs = document.querySelectorAll('#playerInputs input');
            
            for (let input of inputs) {
                if (!input.value.trim()) {
                    alert('Tous les noms des joueurs sont requis');
                    return;
                }
                gameState.players.push({
                    name: input.value.trim(),
                    totalScore: 0
                });
            }

            document.getElementById('playerNames').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            
            gameState.currentRound = 0;
            gameState.rounds = [];
            initNewRound();
        }

        // Initialisation d'une nouvelle ronde
        function initNewRound() {
    gameState.currentRound++;
    document.getElementById('currentRound').textContent = gameState.currentRound;
    
    const roundDesc = gameState.currentRoundDescriptions[gameState.currentRound - 1];
    document.getElementById('roundDescription').textContent = roundDesc;
    
    gameState.currentBets = new Array(gameState.players.length).fill(null);
    gameState.currentScores = new Array(gameState.players.length).fill(null);
    gameState.isCollectingBets = true;
    
    gameState.startingPlayerIndex = (gameState.currentRound - 1) % gameState.players.length;
    gameState.currentPlayerIndex = gameState.startingPlayerIndex;
    
    updateScoreTable();
    updateFooter(); // Appeler updateFooter pour afficher les boutons
}
	function updateRanking() {
            const rankingDisplay = document.getElementById('rankingDisplay');
            
            // Create a sorted copy of players
            const sortedPlayers = gameState.players
                .map((player, index) => ({
                    name: player.name,
                    score: player.totalScore,
                    index: index
                }))
                .sort((a, b) => b.score - a.score);

            // Create ranking HTML
            rankingDisplay.innerHTML = sortedPlayers
                .map((player, index) => `
                    <div class="ranking-item">
                        <span class="rank">${index + 1}.</span>
                        <span>${player.name}:</span>
                        <span class="${player.score >= 0 ? 'score-positive' : 'score-negative'}">
                            ${player.score}
                        </span>
                    </div>
                `)
                .join('');
        }


        // Calcul des points
        function calculatePoints(bet, actual) {
            return bet === actual ? (bet * bet) + 10 : -(Math.abs(bet - actual) * 10);
        }

        // Function to create number buttons (0 to 7)
function createNumberButtons(forbiddenNumber = null) {
    const numberButtons = document.getElementById('numberButtons');
    const roundDesc = gameState.currentRoundDescriptions[gameState.currentRound - 1];
    const roundCards = getCardsFromDescription(roundDesc);
    numberButtons.innerHTML = ''; // Clear existing buttons

    for (let i = 0; i <= 7; i++) {
        const button = document.createElement('button');
        button.className = 'number-button';
        button.textContent = i;
        button.onclick = () => submitFooterInput(i);

        // Disable the forbidden number button
        if (forbiddenNumber !== null && i === forbiddenNumber) {
            button.disabled = true;
        }
	if(i>roundCards) {
            button.disabled = true;
        }

        numberButtons.appendChild(button);
    }
}

        // Function to update the footer
function updateFooter() {
    const footerMessage = document.getElementById('footerMessage');
    const numberButtons = document.getElementById('numberButtons');

    if (gameState.isCollectingBets) {
        const playerName = gameState.players[gameState.currentPlayerIndex].name;
        const roundDesc = gameState.currentRoundDescriptions[gameState.currentRound - 1];
        let message = `Tour de ${playerName} pour miser`;

        const remainingBets = gameState.currentBets.filter(bet => bet === null).length;
        if (remainingBets === 1) {
            const totalBets = gameState.currentBets.reduce((sum, bet) => sum + (bet || 0), 0);
            const roundCards = getCardsFromDescription(roundDesc);
            const forbiddenBet = roundCards - totalBets;
            message += `\n Ne peut pas miser ${forbiddenBet}`;
            createNumberButtons(forbiddenBet); // Disable the forbidden bet
        } else {
		const roundCards = getCardsFromDescription(roundDesc);

            createNumberButtons(); // No forbidden bet
        }

        footerMessage.textContent = message;
    } else {
        const playerName = gameState.players[gameState.currentPlayerIndex].name;
        const playerBet = gameState.currentBets[gameState.currentPlayerIndex];
        footerMessage.textContent = `Points de ${playerName} (mise: ${playerBet})`;
        createNumberButtons(); // No forbidden bet
    }

    updateRanking();
}
	

        // Soumission de l'entrée du footer
        function submitFooterInput(value) {
            if (gameState.isCollectingBets) {
                const isLastPlayer = gameState.currentBets.filter(bet => bet === null).length === 1;
                if (isLastPlayer) {
                    const roundCards = getCardsFromDescription(gameState.currentRoundDescriptions[gameState.currentRound - 1]);
                    const totalBets = gameState.currentBets.reduce((sum, bet) => sum + (bet || 0), 0) + value;

                    if (totalBets === roundCards) {
                        alert(`La somme des mises ne peut pas être égale au nombre de cartes (${roundCards})`);
                        return;
                    }
                }

                gameState.currentBets[gameState.currentPlayerIndex] = value;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;

                if (gameState.currentBets.filter(bet => bet === null).length > 0) {
                    updateFooter();
                } else {
                    gameState.isCollectingBets = false;
                    gameState.currentPlayerIndex = gameState.startingPlayerIndex;
                    updateFooter();
                }
            } else {
                gameState.currentScores[gameState.currentPlayerIndex] = value;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;

                if (gameState.currentScores.filter(score => score === null).length > 0) {
                    updateFooter();
                } else {
                    finishRound();
                }
            }

            updateScoreTable();
        }

        // Finalisation d'une ronde
        function finishRound() {
            const roundData = {
                bets: [...gameState.currentBets],
                scores: [...gameState.currentScores],
                points: gameState.currentBets.map((bet, index) => 
                    calculatePoints(bet, gameState.currentScores[index])),
                description: gameState.currentRoundDescriptions[gameState.currentRound - 1]
            };

            roundData.points.forEach((points, index) => {
                gameState.players[index].totalScore += points;
            });

            gameState.rounds.push(roundData);
            updateScoreTable();

            if (gameState.currentRound < gameState.totalRounds) {
                initNewRound();
            } else {
                const winner = gameState.players.reduce((prev, current) => 
                    (current.totalScore > prev.totalScore) ? current : prev
                );
                alert(`Partie terminée ${winner.name} gagne avec ${winner.totalScore} points !`);
            }
        }

        // Mise à jour du tableau des scores
        function updateScoreTable() {
            const table = document.getElementById('scoreTable');
            let html = `
                <table>
                    <tr>
                        <th style="width: 60px;">Ronde</th>
                        <th style="width: 100px;">Description</th>
                        ${gameState.players.map(player => `
                            <th colspan="3" class="player-column">${player.name}</th>
                        `).join('')}
                    </tr>
                    <tr>
                        <th></th>
                        <th></th>
                        ${gameState.players.map(() => `
                            <th>Mise</th>
                            <th>Score</th>
                            <th>Points</th>
                        `).join('')}
                    </tr>
            `;

            // Affichage des rondes terminées
            gameState.rounds.forEach((round, index) => {
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${round.description}</td>
                        ${gameState.players.map((_, playerIndex) => `
                            <td>${round.bets[playerIndex]}</td>
                            <td>${round.scores[playerIndex]}</td>
                            <td class="${round.points[playerIndex] >= 0 ? 'score-positive' : 'score-negative'}">
                                ${round.points[playerIndex]}
                            </td>
                        `).join('')}
                    </tr>
                `;
            });

            // Affichage de la ronde en cours
            if (gameState.currentRound > 0 && gameState.currentRound > gameState.rounds.length) {
                html += `
                    <tr>
                        <td>${gameState.currentRound}</td>
                        <td>${gameState.currentRoundDescriptions[gameState.currentRound - 1]}</td>
                        ${gameState.players.map((_, playerIndex) => `
                            <td>${gameState.currentBets[playerIndex] ?? '-'}</td>
                            <td>${gameState.currentScores[playerIndex] ?? '-'}</td>
                            <td>-</td>
                        `).join('')}
                    </tr>
                `;
            }

            // Affichage des totaux
            html += `
                <tr>
                    <th colspan="2">Total</th>
                    ${gameState.players.map(player => `
                        <td colspan="3" class="${player.totalScore >= 0 ? 'score-positive' : 'score-negative'}">
                            <strong>${player.totalScore}</strong>
                        </td>
                    `).join('')}
                </tr>
            `;

            html += '</table>';
            table.innerHTML = html;
		updateRanking();
        }
	// Function to handle page leave protection
        function setupPageLeaveProtection() {
            window.addEventListener('beforeunload', handlePageLeave);
        }

        function removePageLeaveProtection() {
            window.removeEventListener('beforeunload', handlePageLeave);
        }

        function handlePageLeave(e) {
            // This will show a standard browser confirmation dialog
            e.preventDefault();
            // Message might not be shown in modern browsers for security reasons,
            // but we still need to set it for older browsers
            e.returnValue = 'La partie en cours sera perdue. Voulez-vous vraiment quitter ?';
        }

        // Modify the startGame function to add protection
        function startGame() {
            gameState.players = [];
            const inputs = document.querySelectorAll('#playerInputs input');
            
            for (let input of inputs) {
                if (!input.value.trim()) {
                    alert('Tous les noms des joueurs sont requis');
                    return;
                }
                gameState.players.push({
                    name: input.value.trim(),
                    totalScore: 0
                });
            }

            document.getElementById('playerNames').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            
            gameState.currentRound = 0;
            gameState.rounds = [];
            
            // Add page leave protection when game starts
            setupPageLeaveProtection();
            
            initNewRound();
        }

        // Modify finishRound function to remove protection when game ends
        function finishRound123() {
            const roundData = {
                bets: [...gameState.currentBets],
                scores: [...gameState.currentScores],
                points: gameState.currentBets.map((bet, index) => 
                    calculatePoints(bet, gameState.currentScores[index])),
                description: gameState.currentRoundDescriptions[gameState.currentRound - 1]
            };

            roundData.points.forEach((points, index) => {
                gameState.players[index].totalScore += points;
            });

            gameState.rounds.push(roundData);
            updateScoreTable();

            if (gameState.currentRound < gameState.totalRounds) {
                initNewRound();
            } else {
                // Remove page leave protection when game ends
                removePageLeaveProtection();
                
                const winner = gameState.players.reduce((prev, current) => 
                    (current.totalScore > prev.totalScore) ? current : prev
                );
                alert(`Partie terminée! ${winner.name} gagne avec ${winner.totalScore} points !`);
            }
        }

    </script>
</body>
</html>