<!DOCTYPE html>
<html lang="fr">
<head>
    <title>FYN Card Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="FYN Card Game">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="FYN Card Game">
    <meta name="theme-color" content="#4361ee">
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3f37c9;
            --success-color: #4cc9f0;
            --danger-color: #f72585;
            --warning-color: #f8961e;
            --info-color: #4895ef;
            --light-color: #f8f9fa;
            --dark-color: #212529;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-color);
            background-color: #f5f7fa;
            padding: 0;
            margin: 0;
            -webkit-font-smoothing: antialiased;
        }

        #app {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
            margin: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: var(--primary-color);
            color: white;
            padding: 1rem;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: white;
            font-size: 1.5rem;
            margin: 0;
        }

        .content {
            padding: 1.5rem;
            flex: 1;
            overflow-y: auto;
        }

        .hidden {
            display: none !important;
        }

        h2 {
            color: var(--dark-color);
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input[type="number"], 
        input[type="text"] {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
        }

        input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }

        .btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .player-order-info {
            background-color: #f0f8ff;
            padding: 0.8rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            font-size: 0.9rem;
            border-left: 4px solid var(--primary-color);
        }

        /* Game info section */
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding: 0.8rem;
            background-color: var(--light-color);
            border-radius: var(--border-radius);
        }

        .round-info {
            font-weight: 500;
        }

        /* Score table */
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th, td {
            padding: 0.8rem;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        th {
            background-color: var(--light-color);
            font-weight: 600;
            white-space: nowrap;
        }

        .player-column {
            background-color: var(--light-color);
            font-weight: 600;
        }

        .score-positive {
            color: #28a745;
            font-weight: bold;
        }

        .score-negative {
            color: var(--danger-color);
            font-weight: bold;
        }

        /* Number buttons */
        .number-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .number-button {
            padding: 0.8rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            text-align: center;
            transition: var(--transition);
        }

        .number-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .number-button:hover:not(:disabled) {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        /* Back button */
        .back-button {
            padding: 0.8rem;
            background-color: var(--warning-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            text-align: center;
            transition: var(--transition);
            grid-column: span 4;
        }

        .back-button:hover {
            background-color: #e07e00;
            transform: translateY(-2px);
        }

        /* Ranking display */
        .ranking {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .ranking-item {
            background-color: var(--light-color);
            padding: 0.8rem 1rem;
            border-radius: var(--border-radius);
            border: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .rank {
            font-weight: bold;
            min-width: 25px;
            text-align: center;
        }

        .player-name {
            font-weight: 500;
        }

        .current-bet {
            color: var(--primary-color);
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .player-score {
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 1rem;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 0.8rem 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            transition: var(--transition);
        }

        .tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Current player message */
        .current-player-message {
            background-color: #e7f3ff;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 500;
            border-left: 4px solid var(--primary-color);
        }

        /* Mobile specific styles */
        @media (max-width: 768px) {
            .content {
                padding: 1rem;
            }

            .header h1 {
                font-size: 1.3rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            .game-info {
                flex-direction: column;
                gap: 0.5rem;
            }

            .number-buttons {
                grid-template-columns: repeat(4, 1fr);
            }

            .number-button {
                padding: 0.7rem;
            }

            th, td {
                padding: 0.6rem 0.4rem;
                font-size: 0.8rem;
            }

            .ranking-item {
                font-size: 0.8rem;
                padding: 0.6rem 0.8rem;
            }

            .tab {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        /* Animation for button clicks */
        .btn:active, .number-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        /* Highlight for active inputs */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.3);
        }

        /* Setup player inputs */
        .player-inputs {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        /* Round description */
        .round-description {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="app-container">
            <div class="header">
                <h1>FYN</h1>
            </div>

            <div class="content">
                <div id="setup" class="setup">
                    <h2>Config du jeu</h2>
                    <div class="form-group">
                        <label for="playerCount">Nombre de joueur (2-6):</label>
                        <input type="number" id="playerCount" min="2" max="6" value="2">
                    </div>
                    <button class="btn btn-primary btn-block" onclick="setupPlayers()">Suivant</button>
                </div>

                <div id="playerNames" class="setup hidden">
                    <h2>Noms des joueurs</h2>
                    <div class="player-order-info">
                        Important: Entrez les noms des joueurs dans le sens anti-horaire depuis le joueur qui distribue √† la premi√®re partie.
                    </div>
                    <div id="playerInputs" class="player-inputs"></div>
                    <button class="btn btn-primary btn-block" onclick="startGame()">Commencer</button>
                </div>

                <div id="game" class="game hidden">
                    <div class="tabs">
                        <button class="tab active" onclick="switchTab('gameTab')">Jeu</button>
                        <button class="tab" onclick="switchTab('resultsTab')">R√©sultats</button>
                    </div>

                    <div id="gameTab" class="tab-content active">
                        <div class="game-info">
                            <div class="round-description" id="roundDescription"></div>
                            <div class="round-info">
                                Tour <span id="currentRound">1</span>/<span id="totalRounds">15</span>
                            </div>
                        </div>
                        
                        <div class="current-player-message" id="currentPlayerMessage"></div>
                        
                        <div class="ranking" id="rankingDisplay"></div>
                        
                        <div class="number-buttons" id="numberButtons"></div>
                    </div>

                    <div id="resultsTab" class="tab-content">
                        <div class="table-container">
                            <div id="scoreTable"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration initiale
        const roundDescriptions = {
            15: [
                "7 cartes",
                "6 cartes",
                "5 cartes",
                "4 cartes",
                "3 cartes",
                "2 cartes",
                "1 carte",
                "1 carte blind",
                "1 carte",
                "2 cartes",
                "3 cartes",
                "4 cartes",
                "5 cartes",
                "6 cartes",
                "7 cartes (Final)"
            ],
            13: [
                "6 cartes",
                "5 cartes",
                "4 cartes",
                "3 cartes",
                "2 cartes",
                "1 carte",
                "1 carte blind",
                "1 carte",
                "2 cartes",
                "3 cartes",
                "4 cartes",
                "5 cartes",
                "6 cartes (Final)"
            ]
        };

        // Game state
        let gameState = {
            players: [],
            rounds: [],
            currentRound: 0,
            totalRounds: 15,
            currentRoundDescriptions: null,
            currentPlayerIndex: 0,
            startingPlayerIndex: 0,
            currentBets: [],
            currentScores: [],
            isCollectingBets: true,
            previousStates: [] // To store previous states for undo functionality
        };

        // Switch between tabs
        function switchTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabId).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Utility function to get card count from description
        function getCardsFromDescription(description) {
            const words = description.split(' ');
            return words[0] === "Final" ? parseInt(words[2]) : parseInt(words[0]);
        }

        // Initialize players setup
        function setupPlayers() {
            const playerCount = parseInt(document.getElementById('playerCount').value);
            if (playerCount < 2 || playerCount > 6) {
                alert('Le nombre de joueur doit √™tre entre 2 et 6');
                return;
            }

            gameState.totalRounds = playerCount === 6 ? 13 : 15;
            gameState.currentRoundDescriptions = roundDescriptions[gameState.totalRounds];
            document.getElementById('totalRounds').textContent = gameState.totalRounds;

            const playerInputs = document.getElementById('playerInputs');
            playerInputs.innerHTML = '';
            
            for (let i = 0; i < playerCount; i++) {
                playerInputs.innerHTML += `
                    <div class="form-group">
                        <label for="player${i}">Joueur ${i + 1}:</label>
                        <input type="text" id="player${i}" required>
                    </div>
                `;
            }

            document.getElementById('setup').classList.add('hidden');
            document.getElementById('playerNames').classList.remove('hidden');
        }

        // Start the game
        function startGame() {
            gameState.players = [];
            const inputs = document.querySelectorAll('#playerInputs input');
            
            for (let input of inputs) {
                if (!input.value.trim()) {
                    alert('Tous les noms des joueurs sont requis');
                    return;
                }
                gameState.players.push({
                    name: input.value.trim(),
                    totalScore: 0
                });
            }

            document.getElementById('playerNames').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            
            gameState.currentRound = 0;
            gameState.rounds = [];
            
            // Add page leave protection
            window.addEventListener('beforeunload', handlePageLeave);
            
            // Activer le plein √©cran et l'anti-veille
            activerPleinEcran();
            acquireWakeLock();
            
            initNewRound();
        }

        // Initialize a new round
        function initNewRound() {
            gameState.currentRound++;
            document.getElementById('currentRound').textContent = gameState.currentRound;
            
            const roundDesc = gameState.currentRoundDescriptions[gameState.currentRound - 1];
            document.getElementById('roundDescription').textContent = roundDesc;
            
            gameState.currentBets = new Array(gameState.players.length).fill(null);
            gameState.currentScores = new Array(gameState.players.length).fill(null);
            gameState.isCollectingBets = true;
            
            gameState.startingPlayerIndex = (gameState.currentRound - 1) % gameState.players.length;
            gameState.currentPlayerIndex = gameState.startingPlayerIndex;
            
            updateScoreTable();
            updateGameInterface();
        }

        // Update player ranking display with current bets
        function updateRanking() {
            const rankingDisplay = document.getElementById('rankingDisplay');
            
            const playersWithData = gameState.players
                .map((player, index) => ({
                    name: player.name,
                    score: player.totalScore,
                    bet: gameState.currentBets[index],
                    index: index
                }))
                .sort((a, b) => b.score - a.score);

            rankingDisplay.innerHTML = playersWithData
                .map((player, index) => `
                    <div class="ranking-item">
                        <div class="player-info">
                            <span class="rank">${index + 1}.</span>
                            <span class="player-name">${player.name}</span>
                            ${player.bet !== null ? `<span class="current-bet">(${player.bet})</span>` : ''}
                        </div>
                        <span class="player-score ${player.score >= 0 ? 'score-positive' : 'score-negative'}">
                            ${player.score}
                        </span>
                    </div>
                `)
                .join('');
        }

        // Calculate points for a bet
        function calculatePoints(bet, actual) {
            return bet === actual ? (bet * bet) + 10 : -(Math.abs(bet - actual) * 10);
        }

        // Create number buttons for input
        function createNumberButtons(forbiddenNumber = null) {
            const numberButtons = document.getElementById('numberButtons');
            const roundDesc = gameState.currentRoundDescriptions[gameState.currentRound - 1];
            const roundCards = getCardsFromDescription(roundDesc);
            numberButtons.innerHTML = '';

            for (let i = 0; i <= 7; i++) {
                const button = document.createElement('button');
                button.className = 'number-button';
                button.textContent = i;
                button.onclick = () => submitInput(i);

                // Disable invalid options
                if ((forbiddenNumber !== null && i === forbiddenNumber) || i > roundCards) {
                    button.disabled = true;
                }

                numberButtons.appendChild(button);
            }

            // Add Back button
            const backButton = document.createElement('button');
            backButton.className = 'back-button';
            backButton.textContent = 'Retour';
            backButton.onclick = undoLastAction;
            numberButtons.appendChild(backButton);
        }

        // Undo the last action
        function undoLastAction() {
            if (gameState.previousStates.length === 0) return;

            // Restore previous state
            const previousState = gameState.previousStates.pop();
            
            // Only allow undo for current round
            if (previousState.round !== gameState.currentRound) {
                alert("Vous ne pouvez revenir en arri√®re que pour le tour actuel.");
                return;
            }
            
            // Restore state
            gameState.currentPlayerIndex = previousState.currentPlayerIndex;
            gameState.currentBets = [...previousState.currentBets];
            gameState.currentScores = [...previousState.currentScores];
            gameState.isCollectingBets = previousState.isCollectingBets;
            gameState.startingPlayerIndex = previousState.startingPlayerIndex;

            updateScoreTable();
            updateGameInterface();
        }

        // Save current state for undo functionality
        function saveState() {
            gameState.previousStates.push({
                currentPlayerIndex: gameState.currentPlayerIndex,
                currentBets: [...gameState.currentBets],
                currentScores: [...gameState.currentScores],
                isCollectingBets: gameState.isCollectingBets,
                startingPlayerIndex: gameState.startingPlayerIndex,
                round: gameState.currentRound
            });

            // Limit the number of saved states to prevent memory issues
            if (gameState.previousStates.length > 10) {
                gameState.previousStates.shift();
            }
        }

        // Update game interface
        function updateGameInterface() {
            const currentPlayerMessage = document.getElementById('currentPlayerMessage');

            if (gameState.isCollectingBets) {
                const playerName = gameState.players[gameState.currentPlayerIndex].name;
                const roundDesc = gameState.currentRoundDescriptions[gameState.currentRound - 1];
                let message = `√Ä ${playerName} de miser`;

                const remainingBets = gameState.currentBets.filter(bet => bet === null).length;
                if (remainingBets === 1) {
                    const totalBets = gameState.currentBets.reduce((sum, bet) => sum + (bet || 0), 0);
                    const roundCards = getCardsFromDescription(roundDesc);
                    const forbiddenBet = roundCards - totalBets;
                    message += ` (Ne peut pas miser ${forbiddenBet})`;
                    createNumberButtons(forbiddenBet);
                } else {
                    createNumberButtons();
                }

                currentPlayerMessage.textContent = message;
            } else {
                const playerName = gameState.players[gameState.currentPlayerIndex].name;
                const playerBet = gameState.currentBets[gameState.currentPlayerIndex];
                currentPlayerMessage.textContent = `√Ä ${playerName} de jouer (Mise: ${playerBet})`;
                createNumberButtons();
            }

            updateRanking();
        }

        // Handle input submission
        function submitInput(value) {
            saveState(); // Save state before making changes

            if (gameState.isCollectingBets) {
                const isLastPlayer = gameState.currentBets.filter(bet => bet === null).length === 1;
                if (isLastPlayer) {
                    const roundCards = getCardsFromDescription(gameState.currentRoundDescriptions[gameState.currentRound - 1]);
                    const totalBets = gameState.currentBets.reduce((sum, bet) => sum + (bet || 0), 0) + value;

                    if (totalBets === roundCards) {
                        alert(`Le total des mises ne peut pas √™tre √©gal au nombre de cartes (${roundCards})`);
                        return;
                    }
                }

                gameState.currentBets[gameState.currentPlayerIndex] = value;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;

                if (gameState.currentBets.filter(bet => bet === null).length > 0) {
                    updateGameInterface();
                } else {
                    gameState.isCollectingBets = false;
                    gameState.currentPlayerIndex = gameState.startingPlayerIndex;
                    updateGameInterface();
                }
            } else {
                gameState.currentScores[gameState.currentPlayerIndex] = value;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;

                if (gameState.currentScores.filter(score => score === null).length > 0) {
                    updateGameInterface();
                } else {
                    finishRound();
                }
            }

            updateScoreTable();
        }

        // Finish the current round
        function finishRound() {
            const roundData = {
                bets: [...gameState.currentBets],
                scores: [...gameState.currentScores],
                points: gameState.currentBets.map((bet, index) => 
                    calculatePoints(bet, gameState.currentScores[index])),
                description: gameState.currentRoundDescriptions[gameState.currentRound - 1]
            };

            roundData.points.forEach((points, index) => {
                gameState.players[index].totalScore += points;
            });

            gameState.rounds.push(roundData);
            updateScoreTable();

            if (gameState.currentRound < gameState.totalRounds) {
                initNewRound();
            } else {
                // Remove page leave protection
                window.removeEventListener('beforeunload', handlePageLeave);
                
                const winner = gameState.players.reduce((prev, current) => 
                    (current.totalScore > prev.totalScore) ? current : prev
                );
                alert(`Partie termin√©e ! ${winner.name} gagne avec ${winner.totalScore} points !`);
            }
        }

        // Update score table display
        function updateScoreTable() {
            const table = document.getElementById('scoreTable');
            let html = `
                <table>
                    <tr>
                        <th>Round</th>
                        <th>Cartes</th>
                        ${gameState.players.map(player => `
                            <th colspan="3" class="player-column">${player.name}</th>
                        `).join('')}
                    </tr>
                    <tr>
                        <th></th>
                        <th></th>
                        ${gameState.players.map(() => `
                            <th>Mise</th>
                            <th>Pris</th>
                            <th>Points</th>
                        `).join('')}
                    </tr>
            `;

            // Completed rounds
            gameState.rounds.forEach((round, index) => {
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${round.description}</td>
                        ${gameState.players.map((_, playerIndex) => `
                            <td>${round.bets[playerIndex]}</td>
                            <td>${round.scores[playerIndex]}</td>
                            <td class="${round.points[playerIndex] >= 0 ? 'score-positive' : 'score-negative'}">
                                ${round.points[playerIndex]}
                            </td>
                        `).join('')}
                    </tr>
                `;
            });

            // Current round
            if (gameState.currentRound > 0 && gameState.currentRound > gameState.rounds.length) {
                html += `
                    <tr>
                        <td>${gameState.currentRound}</td>
                        <td>${gameState.currentRoundDescriptions[gameState.currentRound - 1]}</td>
                        ${gameState.players.map((_, playerIndex) => `
                            <td>${gameState.currentBets[playerIndex] ?? '-'}</td>
                            <td>${gameState.currentScores[playerIndex] ?? '-'}</td>
                            <td>-</td>
                        `).join('')}
                    </tr>
                `;
            }

            // Totals
            html += `
                <tr>
                    <th colspan="2">Total</th>
                    ${gameState.players.map(player => `
                        <td colspan="3" class="${player.totalScore >= 0 ? 'score-positive' : 'score-negative'}">
                            <strong>${player.totalScore}</strong>
                        </td>
                    `).join('')}
                </tr>
            `;

            html += '</table>';
            table.innerHTML = html;
        }

        // Handle page leave confirmation
        function handlePageLeave(e) {
            e.preventDefault();
            e.returnValue = 'La partie en cours sera perdue. √ätes-vous s√ªr de vouloir quitter ?';
        }

        // Variables pour le wake lock et le plein √©cran
        let wakeLock = null;
        let documentInFullscreen = false;

        // Fonction pour activer le mode plein √©cran
        function activerPleinEcran() {
            const element = document.documentElement;
            
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
            
            documentInFullscreen = true;
        }

        // Fonction pour acqu√©rir le wake lock (emp√™che la mise en veille)
        async function acquireWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock activ√©');
                    
                    // R√©acqu√©rir le wake lock en cas de changement de visibilit√©
                    document.addEventListener('visibilitychange', handleVisibilityChange);
                }
            } catch (err) {
                console.error(`Erreur d'activation du Wake Lock: ${err.message}`);
            }
        }

        // Fonction pour g√©rer les changements de visibilit√©
        function handleVisibilityChange() {
            if (document.visibilityState === 'visible' && wakeLock === null) {
                acquireWakeLock();
            }
        }

        // Initialisation pour activer le plein √©cran et l'anti-veille
        function initialiserApp() {
            // Ajouter un bouton pour le plein √©cran
            const header = document.querySelector('.header');
            const fullscreenButton = document.createElement('button');
            fullscreenButton.className = 'btn btn-info';
            fullscreenButton.style.position = 'absolute';
            fullscreenButton.style.right = '10px';
            fullscreenButton.style.top = '50%';
            fullscreenButton.style.transform = 'translateY(-50%)';
            fullscreenButton.style.padding = '0.4rem';
            fullscreenButton.style.fontSize = '0.8rem';
            fullscreenButton.innerHTML = 'üì∫';
            fullscreenButton.title = 'Mode plein √©cran';
            fullscreenButton.onclick = () => {
                activerPleinEcran();
                acquireWakeLock();
            };
            header.appendChild(fullscreenButton);
            
            // G√©rer le changement de visibilit√©
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // √âcouter les modifications de plein √©cran
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        // G√©rer les changements de mode plein √©cran
        function handleFullscreenChange() {
            documentInFullscreen = !!document.fullscreenElement || 
                           !!document.webkitFullscreenElement || 
                           !!document.mozFullScreenElement || 
                           !!document.msFullscreenElement;
                           
            if (documentInFullscreen) {
                acquireWakeLock();
            }
        }

        // Appliquer automatiquement le plein √©cran lors d'un clic
        document.addEventListener('click', function() {
            if (!documentInFullscreen) {
                activerPleinEcran();
                acquireWakeLock();
            }
        }, { once: true });

        // Initialiser l'application apr√®s le chargement
        window.addEventListener('load', initialiserApp);
    </script>
</body>
</html>