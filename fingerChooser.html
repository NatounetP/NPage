<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finger Chooser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Prevent scrolling */
        }
        
        /* Header - always clickable */
        .header {
            background: #0f3460;
            padding: 15px;
            text-align: center;
            border-bottom: 3px solid #e94560;
            position: relative;
            z-index: 1000;
        }
        
        h1 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }
        
        /* Mode selector */
        .mode-selector {
            display: flex;
            gap: 5px;
            margin: 0 auto 15px;
            max-width: 400px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .mode-btn.active {
            background: #e94560;
            color: white;
        }
        
        /* Settings */
        .settings {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }
        
        .settings.active {
            display: block;
        }
        
        .setting {
            color: white;
            margin-bottom: 8px;
        }
        
        /* Progress bar */
        .progress {
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.1);
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: #00b894;
            transition: width 0.1s;
        }
        
        /* Status */
        .status {
            color: white;
            text-align: center;
            padding: 10px;
            font-size: 1rem;
            position: relative;
            z-index: 5;
        }
        
        /* Touch area - covers entire screen */
        .touch-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
        }
        
        /* Finger circles - positioned at EXACT touch point */
        .finger {
            position: fixed; /* FIXED for perfect alignment */
            width: 100px;
            height: 100px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 2rem;
            color: white;
            transform: translate(-50%, -50%); /* Center the circle on touch point */
            border: 4px solid white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 10;
            pointer-events: none; /* Don't interfere with touches */
        }
        
        /* Winner - VERY BIG */
        .finger.winner {
            width: 150px;
            height: 150px;
            font-size: 3rem;
            background: gold !important;
            border-color: gold;
            box-shadow: 0 0 50px gold;
            z-index: 100;
        }
        
        /* Others fade when winner selected */
        .finger:not(.winner) {
            opacity: 0.3;
        }
        
        /* Teams - same colors */
        .team-1 { background: #FF5252 !important; border-color: #FF5252 !important; }
        .team-2 { background: #448AFF !important; border-color: #448AFF !important; }
        .team-3 { background: #64FFDA !important; border-color: #64FFDA !important; }
        .team-4 { background: #FFD740 !important; border-color: #FFD740 !important; }
        .team-5 { background: #E040FB !important; border-color: #E040FB !important; }
        
        /* Ranking colors */
        .rank-1 { background: gold !important; border-color: gold !important; }
        .rank-2 { background: silver !important; border-color: silver !important; }
        .rank-3 { background: #cd7f32 !important; border-color: #cd7f32 !important; }
        .rank-other { background: #667eea !important; border-color: #667eea !important; }
        
        /* Reset button */
        .reset-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #e94560;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            z-index: 100;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .reset-btn:hover {
            background: #ff6b81;
        }
        
        @media (max-width: 600px) {
            .finger {
                width: 90px;
                height: 90px;
                font-size: 1.8rem;
            }
            
            .finger.winner {
                width: 130px;
                height: 130px;
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üëÜ Finger Chooser</h1>
        
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="winner">üéØ Winner</button>
            <button class="mode-btn" data-mode="teams">üë• Teams</button>
            <button class="mode-btn" data-mode="ranking">üèÜ Ranking</button>
        </div>
        
        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="settings" id="teamsSettings">
            <div class="setting">
                Teams: <span id="teamCount">2</span>
                <input type="range" id="teamSlider" min="2" max="5" value="2" style="width: 100%">
            </div>
        </div>
        
        <div class="settings" id="rankingSettings">
            <div class="setting">
                <button class="mode-btn" data-style="numbers">Numbers</button>
                <button class="mode-btn active" data-style="medals">Medals</button>
            </div>
        </div>
    </div>
    
    <div class="status" id="status">
        Touch anywhere with fingers and hold still...
    </div>
    
    <div class="touch-area" id="touchArea"></div>
    
    <button class="reset-btn" onclick="resetAll()">Reset Game</button>

    <script>
        // Simple variables
        let fingers = [];
        let currentMode = 'winner';
        let teamCount = 2;
        let rankingStyle = 'medals';
        let timer = null;
        let progress = 0;
        let lastFingerCount = 0;
        let gameActive = false;
        
        // Setup
        setupButtons();
        setupTouch();
        
        function setupButtons() {
            // Mode buttons
            document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
                btn.onclick = function() {
                    if (gameActive) return; // Don't change mode during active game
                    
                    // Update active button
                    document.querySelectorAll('.mode-btn[data-mode]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Set mode
                    currentMode = this.dataset.mode;
                    
                    // Show/hide settings
                    document.getElementById('teamsSettings').classList.remove('active');
                    document.getElementById('rankingSettings').classList.remove('active');
                    
                    if (currentMode === 'teams') {
                        document.getElementById('teamsSettings').classList.add('active');
                    } else if (currentMode === 'ranking') {
                        document.getElementById('rankingSettings').classList.add('active');
                    }
                    
                    updateStatus();
                };
            });
            
            // Ranking style buttons
            document.querySelectorAll('.mode-btn[data-style]').forEach(btn => {
                btn.onclick = function() {
                    if (gameActive) return;
                    
                    document.querySelectorAll('.mode-btn[data-style]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    rankingStyle = this.dataset.style;
                };
            });
            
            // Team slider
            document.getElementById('teamSlider').oninput = function() {
                if (gameActive) return;
                teamCount = this.value;
                document.getElementById('teamCount').textContent = teamCount;
            };
        }
        
        function setupTouch() {
            // Listen for touches on the entire document
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchcancel', handleTouchCancel, { passive: false });
            
            // Mouse events for desktop
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // Prevent context menu
            document.addEventListener('contextmenu', e => e.preventDefault());
        }
        
        function handleTouchStart(e) {
            // Check if touch is on a UI control
            for (let touch of e.touches) {
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (isUIControl(target)) {
                    // Touch is on a control, don't create finger
                    e.preventDefault();
                    return;
                }
            }
            
            e.preventDefault();
            
            // Process all touches
            for (let touch of e.touches) {
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (!isUIControl(target) && !gameActive) {
                    // Create finger at EXACT touch position
                    if (!fingers.find(f => f.id === touch.identifier)) {
                        createFinger(touch.identifier, touch.clientX, touch.clientY);
                    }
                }
            }
            
            checkStability();
            updateStatus();
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (gameActive) return;
            
            // Update finger positions
            for (let touch of e.touches) {
                const finger = fingers.find(f => f.id === touch.identifier);
                if (finger) {
                    // Update to EXACT touch position
                    finger.x = touch.clientX;
                    finger.y = touch.clientY;
                    finger.element.style.left = touch.clientX + 'px';
                    finger.element.style.top = touch.clientY + 'px';
                }
            }
            
            checkStability();
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            
            // Get current touches
            const currentTouches = new Set();
            for (let touch of e.touches) {
                currentTouches.add(touch.identifier);
            }
            
            // Remove fingers that are no longer touching
            fingers = fingers.filter(finger => {
                if (!currentTouches.has(finger.id)) {
                    if (finger.element.parentNode) {
                        finger.element.parentNode.removeChild(finger.element);
                    }
                    return false;
                }
                return true;
            });
            
            checkStability();
            updateStatus();
        }
        
        function handleTouchCancel(e) {
            e.preventDefault();
            // Clear all touches
            fingers.forEach(finger => {
                if (finger.element.parentNode) {
                    finger.element.parentNode.removeChild(finger.element);
                }
            });
            fingers = [];
            checkStability();
            updateStatus();
        }
        
        // Mouse handlers for desktop testing
        let mouseId = null;
        
        function handleMouseDown(e) {
            if (e.button !== 0 || gameActive) return;
            if (isUIControl(e.target)) return;
            
            mouseId = 'mouse_' + Date.now();
            createFinger(mouseId, e.clientX, e.clientY);
            checkStability();
            updateStatus();
        }
        
        function handleMouseMove(e) {
            if (!mouseId || gameActive) return;
            
            const finger = fingers.find(f => f.id === mouseId);
            if (finger) {
                finger.x = e.clientX;
                finger.y = e.clientY;
                finger.element.style.left = e.clientX + 'px';
                finger.element.style.top = e.clientY + 'px';
                checkStability();
            }
        }
        
        function handleMouseUp(e) {
            if (!mouseId) return;
            
            fingers = fingers.filter(f => {
                if (f.id === mouseId) {
                    if (f.element.parentNode) {
                        f.element.parentNode.removeChild(f.element);
                    }
                    return false;
                }
                return true;
            });
            mouseId = null;
            stopTimer();
            updateStatus();
        }
        
        function isUIControl(element) {
            // Check if element is a UI control
            const uiTags = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'];
            const uiClasses = ['mode-btn', 'ranking-style-btn', 'team-slider', 'reset-btn'];
            
            let current = element;
            while (current && current !== document.body) {
                // Check tag
                if (uiTags.includes(current.tagName)) {
                    return true;
                }
                
                // Check classes
                for (const className of uiClasses) {
                    if (current.classList && current.classList.contains(className)) {
                        return true;
                    }
                }
                
                // Check if in header area
                if (current.classList && current.classList.contains('header')) {
                    return true;
                }
                
                current = current.parentElement;
            }
            
            return false;
        }
        
        function createFinger(id, x, y) {
            const fingerDiv = document.createElement('div');
            fingerDiv.className = 'finger';
            fingerDiv.textContent = (fingers.length + 1).toString();
            
            // Position at EXACT touch point - using FIXED positioning
            fingerDiv.style.left = x + 'px';
            fingerDiv.style.top = y + 'px';
            
            // Random color for new finger (will be changed in teams mode)
            const colors = ['#FF5252', '#448AFF', '#64FFDA', '#FFD740', '#E040FB', '#667eea', '#764ba2'];
            fingerDiv.style.background = colors[fingers.length % colors.length];
            
            document.body.appendChild(fingerDiv);
            
            fingers.push({
                id: id,
                x: x,
                y: y,
                element: fingerDiv,
                number: fingers.length + 1
            });
        }
        
        function checkStability() {
            // Reset timer if finger count changes
            if (fingers.length !== lastFingerCount) {
                lastFingerCount = fingers.length;
                stopTimer();
                
                // Start new timer if we have enough fingers
                if (fingers.length >= 2 && !gameActive) {
                    startTimer();
                }
            }
        }
        
        function startTimer() {
            if (timer) return;
            
            progress = 0;
            updateProgress();
            
            timer = setInterval(() => {
                progress += 100/30; // 3 seconds total
                updateProgress();
                
                if (progress >= 100) {
                    stopTimer();
                    gameActive = true;
                    runMode();
                }
            }, 100);
        }
        
        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
            progress = 0;
            updateProgress();
        }
        
        function updateProgress() {
            document.getElementById('progressBar').style.width = progress + '%';
        }
        
        function updateStatus() {
            const status = document.getElementById('status');
            
            if (gameActive) {
                status.textContent = 'Game complete - Press Reset to start over';
            } else if (fingers.length === 0) {
                status.textContent = 'Touch anywhere with fingers and hold still...';
            } else if (fingers.length === 1) {
                status.textContent = 'Add more fingers (need at least 2)';
            } else if (timer) {
                const secondsLeft = Math.ceil((100 - progress) / (100/3));
                status.textContent = `${fingers.length} fingers - ${secondsLeft}s...`;
            } else {
                status.textContent = `${fingers.length} fingers - Hold still!`;
            }
        }
        
        function runMode() {
            if (fingers.length === 0) return;
            
            switch(currentMode) {
                case 'winner':
                    selectWinner();
                    break;
                case 'teams':
                    createTeams();
                    break;
                case 'ranking':
                    createRanking();
                    break;
            }
        }
        
        function selectWinner() {
            const winnerIndex = Math.floor(Math.random() * fingers.length);
            
            // Make winner BIG and gold, fade others
            fingers.forEach((finger, index) => {
                if (index === winnerIndex) {
                    finger.element.classList.add('winner');
                    finger.element.textContent = 'üëë';
                } else {
                    finger.element.style.opacity = '0.3';
                }
            });
            
            // NO POPUP - result shown on circles only
        }
        
        function createTeams() {
            // Shuffle fingers
            const shuffled = [...fingers].sort(() => Math.random() - 0.5);
            
            // Distribute into teams
            const teams = [];
            const teamColors = ['team-1', 'team-2', 'team-3', 'team-4', 'team-5'];
            
            for (let i = 0; i < teamCount; i++) {
                teams.push([]);
            }
            
            shuffled.forEach((finger, index) => {
                const teamIndex = index % teamCount;
                teams[teamIndex].push(finger);
                
                // Apply team color and number - SAME COLOR FOR ALL TEAM MEMBERS
                // Reset class first
                finger.element.className = 'finger ' + teamColors[teamIndex];
                finger.element.textContent = 'T' + (teamIndex + 1);
            });
            
            // NO POPUP - results shown on circles only
        }
        
        function createRanking() {
            // Shuffle for random ranking
            const shuffled = [...fingers].sort(() => Math.random() - 0.5);
            
            shuffled.forEach((finger, index) => {
                // Reset class
                finger.element.className = 'finger';
                
                // Add rank class
                if (index === 0) {
                    finger.element.classList.add('rank-1');
                    finger.element.textContent = rankingStyle === 'medals' ? 'ü•á' : '1';
                } else if (index === 1) {
                    finger.element.classList.add('rank-2');
                    finger.element.textContent = rankingStyle === 'medals' ? 'ü•à' : '2';
                } else if (index === 2) {
                    finger.element.classList.add('rank-3');
                    finger.element.textContent = rankingStyle === 'medals' ? 'ü•â' : '3';
                } else {
                    finger.element.classList.add('rank-other');
                    finger.element.textContent = (index + 1).toString();
                }
            });
            
            // NO POPUP - results shown on circles only
        }
        
        function resetAll() {
            // Remove all fingers
            fingers.forEach(finger => {
                if (finger.element.parentNode) {
                    finger.element.parentNode.removeChild(finger.element);
                }
            });
            fingers = [];
            
            // Reset game state
            gameActive = false;
            lastFingerCount = 0;
            mouseId = null;
            
            // Reset UI
            stopTimer();
            updateStatus();
        }
    </script>
</body>
</html>